---
title: 'Trends'
---

In order to spot trends in our production traffic, let's first open the Unify console,
and click on "Interfaces" to build our trend detection interface.

As per the
[notebook]()
simulating our usage, the project is called `"EdTech"`.

Let's select this project from the dropdown at the top. If you don't see the project,
then make sure you've set up your API key in the
[notebook]()
correctly.

Let's open our previous `"Traffic"` interface as a starting point, but let's
immediately `"Save As"` a new interface, calling this one `"Trends"`. This ensures
we don't overwrite our previous interface configuration.

Let's delete the plots, and keep only one of the tables, and let's also remove the
table filters.

![](demo.gif)

The traffic is continuing to stream in real time, which can be useful, but it can
also create confusion as every time the table loads with new data included. In order
to "freeze" the data, the freeze button can be pressed, which will prevent any
future logs from being added to the table, from the moment when the freeze button
was pressed.

![](demo.gif)

Let's explore which students are making the most use of the platform, and answering
the highest volume of questions. Let's click `group by` above the `email` field.
This will group each log on a student-by-student basis, each of which can be
unfolded to see the raw data.

![](demo.gif)

The reduction metrics of each group can be seen plotted in the table. By default the
`mean` is plotted, but this can be changed at the bottom of the table. Let's change
the metric to `count` instead, and let's order any of the columns in ascending order.
It doesn't matter which column, they all have the same `count` value, which refers to
the number of logs (rows), and so is independent of the column values.

![](demo.gif)

When `group by` is applied, then these groups are always ordered based on the
reduction metric selected at the bottom left of the table, in this case `count`.
With this configuration applied, we have the students making most use shown at the
top, and those making the least use shown at the bottom.

Not all of the students are shown by default due to pagination. You can either
continue scrolling to the bottom of the page to get all logs, or press `show all` to
reveal *all* of the logs in the project within the table.

![](demo.gif)

In the case of very memory-intensive data, this *might* slow down the application.
In such cases, you should simply press the same button again to hide the logs and
revert to the default pagination setting again.

We can plot the distribution of usage across each student via a histogram. We simply
need to select the email address for the axis. Given that this is non-numeric data,
we don't need to specify the number of buckets. A separate bar will be plotted for
each unique email address.

![](demo.gif)

Let's do a slightly more complicated example, and find the average time in
the day when boys vs girls are on the platform. First, let's create a new column which
calculates the *remainder* timestamp when dividing by the number of days, which gives
us the time of day for the request.

![](demo.gif)

If we chose `mean` as our reduction statistic, and group by `gender`, we'll then get
the average time of day for the requests shown in the table.

![](demo.gif)

Similarly, if we want to see how the average time of usage in the day varies across
different ages, we can first create a new column which buckets the ages into `n`
buckets, lets say 10 in this case.

![](demo.gif)

We can then group by this new bucketed column to get all of the rows grouped into
these buckets. The `time_of_day` mean values now present the mean values for each of
these age groups. We can also sort by the `time_of_day` column, which will order these
groups based on their mean time of day. We can see that younger people are typically
on the platform much later in the evening, whilst older people use it in the morning.

![](demo.gif)

These are just examples. We can manipulate the data in all kinds of other ways. For
example, if we want to see which questions have the most marks available, we can
group by the question, and then sort by the marks available:

![](demo.gif)

If we want to see questions which include an image in both the question and the
markscheme, we can filter to ensure both columns exist.

![](demo.gif)

You should play around with this interface yourself, and explore other useful
representations you can create by juggling things around, and applying
filters, sorting, grouping, and various plots. If you find a useful representation
of the data, then you can save this as an interface and come back to this view of
the data at a later stage.
